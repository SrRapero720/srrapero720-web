/// <reference types="node" />
import fs from "fs";
import SocketIO from "socket.io";
import { ConsoleFilteredColors } from "../tools/colors.js";
import { TimeMethod } from "../tools/time.js";
export interface SrConsoleConfig {
    filter?: string[];
    time?: keyof TimeMethod;
    logs?: {
        active: boolean;
        path: string;
    };
}
declare class SrConsoleUtil {
    config: SrConsoleConfig;
    _fileStream?: fs.WriteStream;
    constructor(config?: SrConsoleConfig);
    memory: number;
    protected _groups: number;
    protected _counts: object;
    protected stdOut: NodeJS.WriteStream & {
        fd: 1;
    };
    protected stdErr: NodeJS.WriteStream & {
        fd: 2;
    };
    protected stdIn: NodeJS.ReadStream & {
        fd: 0;
    };
    protected socketIO?: SocketIO.Server;
    protected _readMemory(): void;
    protected _resolveTypeOfColor(values: any[], color: keyof ConsoleFilteredColors, method: 'normal' | 'filtered'): string;
    protected _sendToSockets(method: 'in' | 'out' | 'err', msg: string): void;
    protected _printToConsole(color: keyof ConsoleFilteredColors, std: 'in' | 'out' | 'err', message: any, optMessage: any[]): Promise<void>;
}
export declare class SrConsole extends SrConsoleUtil {
    constructor(config?: SrConsoleConfig);
    SocketIO(server: SocketIO.Server): boolean;
    /**
     * @color Blue/Classic
     * @description Imprime en la consola los argumentos enviados en color Azul
     */
    log(msg: any, ...optMessage: any[]): void;
    /**
     * @color Blue/Classic
     * @description Filtra palabras o simbolos (de un string) e imprime el resultado [solo funciona para el primer argumento]
     */
    send(msg: string, ...optMessage: any[]): void;
    warn(msg: any, ...optMessage: any[]): void;
    debug(msg: any, ...optMessage: any[]): void;
    info(msg: any, ...optMessage: any[]): void;
    error(msg: any, ...optMessage: any[]): void;
    err(msg: any, ...optMessage: any[]): void;
    success(msg: any, ...optMessage: any[]): void;
    FatalE(msg: Error): void;
    assert(msg: any, ...optMessage: any[]): void;
    clear(): void;
    group(msg: any, ...optMessage: any[]): void;
    groupEnd(msg: any, ...optMessage: any[]): void;
    groupCollapsed(msg: any, ...optMessage: any[]): void;
    /**
     * @private
     */
    count(): void;
    /**
     * @private
     */
    countReset(): void;
    /**
     * @private
     */
    dir(): void;
    /**
     * @private
     */
    dirxml(): void;
    /**
     * @private
     */
    table(): void;
    /**
     * @private
     */
    time(): void;
    /**
     * @private
     */
    timeEnd(): void;
    /**
     * @private
     */
    timeLog(): void;
    /**
     * @private
     */
    timeStamp(): void;
    /**
     * @private
     */
    trace(): void;
    /**
     * @private
     */
    profile(): void;
    /**
     * @private
     */
    profileEnd(): void;
}
export default SrConsole;
